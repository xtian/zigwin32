//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (5)
//--------------------------------------------------------------------------------
pub const FILE_CACHE_MAX_HARD_ENABLE = @as(u32, 1);
pub const FILE_CACHE_MAX_HARD_DISABLE = @as(u32, 2);
pub const FILE_CACHE_MIN_HARD_ENABLE = @as(u32, 4);
pub const FILE_CACHE_MIN_HARD_DISABLE = @as(u32, 8);
pub const MEHC_PATROL_SCRUBBER_PRESENT = @as(u32, 1);

//--------------------------------------------------------------------------------
// Section: Types (14)
//--------------------------------------------------------------------------------
// TODO: this type has a FreeFunc 'HeapDestroy', what can Zig do with this information?
pub const HeapHandle = isize;

pub const HEAP_SUMMARY = extern struct {
    cb: u32,
    cbAllocated: usize,
    cbCommitted: usize,
    cbReserved: usize,
    cbMaxReserve: usize,
};

pub const MEMORY_RESOURCE_NOTIFICATION_TYPE = extern enum(i32) {
    LowMemoryResourceNotification = 0,
    HighMemoryResourceNotification = 1,
};
pub const LowMemoryResourceNotification = MEMORY_RESOURCE_NOTIFICATION_TYPE.LowMemoryResourceNotification;
pub const HighMemoryResourceNotification = MEMORY_RESOURCE_NOTIFICATION_TYPE.HighMemoryResourceNotification;

pub const WIN32_MEMORY_RANGE_ENTRY = extern struct {
    VirtualAddress: *c_void,
    NumberOfBytes: usize,
};

pub const PBAD_MEMORY_CALLBACK_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const OFFER_PRIORITY = extern enum(i32) {
    VeryLow = 1,
    Low = 2,
    BelowNormal = 3,
    Normal = 4,
};
pub const VmOfferPriorityVeryLow = OFFER_PRIORITY.VeryLow;
pub const VmOfferPriorityLow = OFFER_PRIORITY.Low;
pub const VmOfferPriorityBelowNormal = OFFER_PRIORITY.BelowNormal;
pub const VmOfferPriorityNormal = OFFER_PRIORITY.Normal;

pub const WIN32_MEMORY_INFORMATION_CLASS = extern enum(i32) {
    o = 0,
};
pub const MemoryRegionInfo = WIN32_MEMORY_INFORMATION_CLASS.o;

pub const WIN32_MEMORY_REGION_INFORMATION = extern struct {
    AllocationBase: *c_void,
    AllocationProtect: u32,
    Anonymous: extern union {
        Flags: u32,
        Anonymous: extern struct {
            _bitfield: u32,
        },
    },
    RegionSize: usize,
    CommitSize: usize,
};

pub const HEAP_FLAGS = extern enum(u32) {
    NONE = 0,
    NO_SERIALIZE = 1,
    GROWABLE = 2,
    GENERATE_EXCEPTIONS = 4,
    ZERO_MEMORY = 8,
    REALLOC_IN_PLACE_ONLY = 16,
    TAIL_CHECKING_ENABLED = 32,
    FREE_CHECKING_ENABLED = 64,
    DISABLE_COALESCE_ON_FREE = 128,
    CREATE_ALIGN_16 = 65536,
    CREATE_ENABLE_TRACING = 131072,
    CREATE_ENABLE_EXECUTE = 262144,
    MAXIMUM_TAG = 4095,
    PSEUDO_TAG_FLAG = 32768,
    TAG_SHIFT = 18,
    CREATE_SEGMENT_HEAP = 256,
    CREATE_HARDENED = 512,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        NO_SERIALIZE: u1 = 0,
        GROWABLE: u1 = 0,
        GENERATE_EXCEPTIONS: u1 = 0,
        ZERO_MEMORY: u1 = 0,
        REALLOC_IN_PLACE_ONLY: u1 = 0,
        TAIL_CHECKING_ENABLED: u1 = 0,
        FREE_CHECKING_ENABLED: u1 = 0,
        DISABLE_COALESCE_ON_FREE: u1 = 0,
        CREATE_ALIGN_16: u1 = 0,
        CREATE_ENABLE_TRACING: u1 = 0,
        CREATE_ENABLE_EXECUTE: u1 = 0,
        MAXIMUM_TAG: u1 = 0,
        PSEUDO_TAG_FLAG: u1 = 0,
        TAG_SHIFT: u1 = 0,
        CREATE_SEGMENT_HEAP: u1 = 0,
        CREATE_HARDENED: u1 = 0,
    }) HEAP_FLAGS {
        return @intToEnum(HEAP_FLAGS,
              (if (o.NONE == 1) @enumToInt(HEAP_FLAGS.NONE) else 0)
            | (if (o.NO_SERIALIZE == 1) @enumToInt(HEAP_FLAGS.NO_SERIALIZE) else 0)
            | (if (o.GROWABLE == 1) @enumToInt(HEAP_FLAGS.GROWABLE) else 0)
            | (if (o.GENERATE_EXCEPTIONS == 1) @enumToInt(HEAP_FLAGS.GENERATE_EXCEPTIONS) else 0)
            | (if (o.ZERO_MEMORY == 1) @enumToInt(HEAP_FLAGS.ZERO_MEMORY) else 0)
            | (if (o.REALLOC_IN_PLACE_ONLY == 1) @enumToInt(HEAP_FLAGS.REALLOC_IN_PLACE_ONLY) else 0)
            | (if (o.TAIL_CHECKING_ENABLED == 1) @enumToInt(HEAP_FLAGS.TAIL_CHECKING_ENABLED) else 0)
            | (if (o.FREE_CHECKING_ENABLED == 1) @enumToInt(HEAP_FLAGS.FREE_CHECKING_ENABLED) else 0)
            | (if (o.DISABLE_COALESCE_ON_FREE == 1) @enumToInt(HEAP_FLAGS.DISABLE_COALESCE_ON_FREE) else 0)
            | (if (o.CREATE_ALIGN_16 == 1) @enumToInt(HEAP_FLAGS.CREATE_ALIGN_16) else 0)
            | (if (o.CREATE_ENABLE_TRACING == 1) @enumToInt(HEAP_FLAGS.CREATE_ENABLE_TRACING) else 0)
            | (if (o.CREATE_ENABLE_EXECUTE == 1) @enumToInt(HEAP_FLAGS.CREATE_ENABLE_EXECUTE) else 0)
            | (if (o.MAXIMUM_TAG == 1) @enumToInt(HEAP_FLAGS.MAXIMUM_TAG) else 0)
            | (if (o.PSEUDO_TAG_FLAG == 1) @enumToInt(HEAP_FLAGS.PSEUDO_TAG_FLAG) else 0)
            | (if (o.TAG_SHIFT == 1) @enumToInt(HEAP_FLAGS.TAG_SHIFT) else 0)
            | (if (o.CREATE_SEGMENT_HEAP == 1) @enumToInt(HEAP_FLAGS.CREATE_SEGMENT_HEAP) else 0)
            | (if (o.CREATE_HARDENED == 1) @enumToInt(HEAP_FLAGS.CREATE_HARDENED) else 0)
        );
    }
};
pub const HEAP_NONE = HEAP_FLAGS.NONE;
pub const HEAP_NO_SERIALIZE = HEAP_FLAGS.NO_SERIALIZE;
pub const HEAP_GROWABLE = HEAP_FLAGS.GROWABLE;
pub const HEAP_GENERATE_EXCEPTIONS = HEAP_FLAGS.GENERATE_EXCEPTIONS;
pub const HEAP_ZERO_MEMORY = HEAP_FLAGS.ZERO_MEMORY;
pub const HEAP_REALLOC_IN_PLACE_ONLY = HEAP_FLAGS.REALLOC_IN_PLACE_ONLY;
pub const HEAP_TAIL_CHECKING_ENABLED = HEAP_FLAGS.TAIL_CHECKING_ENABLED;
pub const HEAP_FREE_CHECKING_ENABLED = HEAP_FLAGS.FREE_CHECKING_ENABLED;
pub const HEAP_DISABLE_COALESCE_ON_FREE = HEAP_FLAGS.DISABLE_COALESCE_ON_FREE;
pub const HEAP_CREATE_ALIGN_16 = HEAP_FLAGS.CREATE_ALIGN_16;
pub const HEAP_CREATE_ENABLE_TRACING = HEAP_FLAGS.CREATE_ENABLE_TRACING;
pub const HEAP_CREATE_ENABLE_EXECUTE = HEAP_FLAGS.CREATE_ENABLE_EXECUTE;
pub const HEAP_MAXIMUM_TAG = HEAP_FLAGS.MAXIMUM_TAG;
pub const HEAP_PSEUDO_TAG_FLAG = HEAP_FLAGS.PSEUDO_TAG_FLAG;
pub const HEAP_TAG_SHIFT = HEAP_FLAGS.TAG_SHIFT;
pub const HEAP_CREATE_SEGMENT_HEAP = HEAP_FLAGS.CREATE_SEGMENT_HEAP;
pub const HEAP_CREATE_HARDENED = HEAP_FLAGS.CREATE_HARDENED;

pub const UNMAP_VIEW_OF_FILE_FLAGS = extern enum(u32) {
    UNMAP_NONE = 0,
    UNMAP_WITH_TRANSIENT_BOOST = 1,
    PRESERVE_PLACEHOLDER = 2,
};
pub const MEM_UNMAP_NONE = UNMAP_VIEW_OF_FILE_FLAGS.UNMAP_NONE;
pub const MEM_UNMAP_WITH_TRANSIENT_BOOST = UNMAP_VIEW_OF_FILE_FLAGS.UNMAP_WITH_TRANSIENT_BOOST;
pub const MEM_PRESERVE_PLACEHOLDER = UNMAP_VIEW_OF_FILE_FLAGS.PRESERVE_PLACEHOLDER;

pub const VIRTUAL_FREE_TYPE = extern enum(u32) {
    DECOMMIT = 16384,
    RELEASE = 32768,
};
pub const MEM_DECOMMIT = VIRTUAL_FREE_TYPE.DECOMMIT;
pub const MEM_RELEASE = VIRTUAL_FREE_TYPE.RELEASE;

pub const VIRTUAL_ALLOCATION_TYPE = extern enum(u32) {
    COMMIT = 4096,
    RESERVE = 8192,
    COMMIT_RESERVE = 12288,
    RESET = 524288,
    RESET_UNDO = 16777216,
    REPLACE_PLACEHOLDER = 16384,
    LARGE_PAGES = 536870912,
    RESERVE_PLACEHOLDER = 262144,
    FREE = 65536,
};
pub const MEM_COMMIT = VIRTUAL_ALLOCATION_TYPE.COMMIT;
pub const MEM_RESERVE = VIRTUAL_ALLOCATION_TYPE.RESERVE;
pub const MEM_RESET = VIRTUAL_ALLOCATION_TYPE.RESET;
pub const MEM_RESET_UNDO = VIRTUAL_ALLOCATION_TYPE.RESET_UNDO;
pub const MEM_REPLACE_PLACEHOLDER = VIRTUAL_ALLOCATION_TYPE.REPLACE_PLACEHOLDER;
pub const MEM_LARGE_PAGES = VIRTUAL_ALLOCATION_TYPE.LARGE_PAGES;
pub const MEM_RESERVE_PLACEHOLDER = VIRTUAL_ALLOCATION_TYPE.RESERVE_PLACEHOLDER;
pub const MEM_FREE = VIRTUAL_ALLOCATION_TYPE.FREE;

pub const LOCAL_ALLOC_FLAGS = extern enum(u32) {
    LHND = 66,
    LMEM_FIXED = 0,
    LMEM_MOVEABLE = 2,
    LMEM_ZEROINIT = 64,
    LPTR = 64,
    NONZEROLHND = 2,
    NONZEROLPTR = 0,
    _,
    pub fn initFlags(o: struct {
        LHND: u1 = 0,
        LMEM_FIXED: u1 = 0,
        LMEM_MOVEABLE: u1 = 0,
        LMEM_ZEROINIT: u1 = 0,
        LPTR: u1 = 0,
        NONZEROLHND: u1 = 0,
        NONZEROLPTR: u1 = 0,
    }) LOCAL_ALLOC_FLAGS {
        return @intToEnum(LOCAL_ALLOC_FLAGS,
              (if (o.LHND == 1) @enumToInt(LOCAL_ALLOC_FLAGS.LHND) else 0)
            | (if (o.LMEM_FIXED == 1) @enumToInt(LOCAL_ALLOC_FLAGS.LMEM_FIXED) else 0)
            | (if (o.LMEM_MOVEABLE == 1) @enumToInt(LOCAL_ALLOC_FLAGS.LMEM_MOVEABLE) else 0)
            | (if (o.LMEM_ZEROINIT == 1) @enumToInt(LOCAL_ALLOC_FLAGS.LMEM_ZEROINIT) else 0)
            | (if (o.LPTR == 1) @enumToInt(LOCAL_ALLOC_FLAGS.LPTR) else 0)
            | (if (o.NONZEROLHND == 1) @enumToInt(LOCAL_ALLOC_FLAGS.NONZEROLHND) else 0)
            | (if (o.NONZEROLPTR == 1) @enumToInt(LOCAL_ALLOC_FLAGS.NONZEROLPTR) else 0)
        );
    }
};
pub const LHND = LOCAL_ALLOC_FLAGS.LHND;
pub const LMEM_FIXED = LOCAL_ALLOC_FLAGS.LMEM_FIXED;
pub const LMEM_MOVEABLE = LOCAL_ALLOC_FLAGS.LMEM_MOVEABLE;
pub const LMEM_ZEROINIT = LOCAL_ALLOC_FLAGS.LMEM_ZEROINIT;
pub const LPTR = LOCAL_ALLOC_FLAGS.LPTR;
pub const NONZEROLHND = LOCAL_ALLOC_FLAGS.NONZEROLHND;
pub const NONZEROLPTR = LOCAL_ALLOC_FLAGS.NONZEROLPTR;

pub const GLOBAL_ALLOC_FLAGS = extern enum(u32) {
    HND = 66,
    MEM_FIXED = 0,
    MEM_MOVEABLE = 2,
    MEM_ZEROINIT = 64,
    PTR = 64,
    _,
    pub fn initFlags(o: struct {
        HND: u1 = 0,
        MEM_FIXED: u1 = 0,
        MEM_MOVEABLE: u1 = 0,
        MEM_ZEROINIT: u1 = 0,
        PTR: u1 = 0,
    }) GLOBAL_ALLOC_FLAGS {
        return @intToEnum(GLOBAL_ALLOC_FLAGS,
              (if (o.HND == 1) @enumToInt(GLOBAL_ALLOC_FLAGS.HND) else 0)
            | (if (o.MEM_FIXED == 1) @enumToInt(GLOBAL_ALLOC_FLAGS.MEM_FIXED) else 0)
            | (if (o.MEM_MOVEABLE == 1) @enumToInt(GLOBAL_ALLOC_FLAGS.MEM_MOVEABLE) else 0)
            | (if (o.MEM_ZEROINIT == 1) @enumToInt(GLOBAL_ALLOC_FLAGS.MEM_ZEROINIT) else 0)
            | (if (o.PTR == 1) @enumToInt(GLOBAL_ALLOC_FLAGS.PTR) else 0)
        );
    }
};
pub const GHND = GLOBAL_ALLOC_FLAGS.HND;
pub const GMEM_FIXED = GLOBAL_ALLOC_FLAGS.MEM_FIXED;
pub const GMEM_MOVEABLE = GLOBAL_ALLOC_FLAGS.MEM_MOVEABLE;
pub const GMEM_ZEROINIT = GLOBAL_ALLOC_FLAGS.MEM_ZEROINIT;
pub const GPTR = GLOBAL_ALLOC_FLAGS.PTR;


//--------------------------------------------------------------------------------
// Section: Functions (87)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapCreate(
    flOptions: HEAP_FLAGS,
    dwInitialSize: usize,
    dwMaximumSize: usize,
) callconv(@import("std").os.windows.WINAPI) HeapHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapDestroy(
    hHeap: HeapHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapAlloc(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
    dwBytes: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapReAlloc(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
    lpMem: ?*c_void,
    dwBytes: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapFree(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
    lpMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapSize(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
    lpMem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcessHeap(
) callconv(@import("std").os.windows.WINAPI) HeapHandle;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapCompact(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapSetInformation(
    HeapHandle: HeapHandle,
    HeapInformationClass: HEAP_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    HeapInformation: ?*c_void,
    HeapInformationLength: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapValidate(
    hHeap: HeapHandle,
    dwFlags: HEAP_FLAGS,
    lpMem: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn HeapSummary(
    hHeap: HANDLE,
    dwFlags: u32,
    lpSummary: *HEAP_SUMMARY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetProcessHeaps(
    NumberOfHeaps: u32,
    ProcessHeaps: [*]HeapHandle,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapLock(
    hHeap: HeapHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapUnlock(
    hHeap: HeapHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapWalk(
    hHeap: HeapHandle,
    lpEntry: *PROCESS_HEAP_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn HeapQueryInformation(
    HeapHandle: HeapHandle,
    HeapInformationClass: HEAP_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    HeapInformation: ?*c_void,
    HeapInformationLength: usize,
    ReturnLength: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualAlloc(
    lpAddress: ?*c_void,
    dwSize: usize,
    flAllocationType: VIRTUAL_ALLOCATION_TYPE,
    flProtect: PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualProtect(
    lpAddress: *c_void,
    dwSize: usize,
    flNewProtect: PAGE_TYPE,
    lpflOldProtect: *PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualFree(
    lpAddress: *c_void,
    dwSize: usize,
    dwFreeType: VIRTUAL_FREE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualQuery(
    lpAddress: ?*const c_void,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: *MEMORY_BASIC_INFORMATION,
    dwLength: usize,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualAllocEx(
    hProcess: HANDLE,
    lpAddress: ?*c_void,
    dwSize: usize,
    flAllocationType: VIRTUAL_ALLOCATION_TYPE,
    flProtect: PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualProtectEx(
    hProcess: HANDLE,
    lpAddress: *c_void,
    dwSize: usize,
    flNewProtect: PAGE_TYPE,
    lpflOldProtect: *PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualQueryEx(
    hProcess: HANDLE,
    lpAddress: ?*const c_void,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: *MEMORY_BASIC_INFORMATION,
    dwLength: usize,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateFileMappingW(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: PAGE_TYPE,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OpenFileMappingW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MapViewOfFile(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: FILE_MAP,
    dwFileOffsetHigh: u32,
    dwFileOffsetLow: u32,
    dwNumberOfBytesToMap: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MapViewOfFileEx(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: FILE_MAP,
    dwFileOffsetHigh: u32,
    dwFileOffsetLow: u32,
    dwNumberOfBytesToMap: usize,
    lpBaseAddress: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualFreeEx(
    hProcess: HANDLE,
    lpAddress: *c_void,
    dwSize: usize,
    dwFreeType: VIRTUAL_FREE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FlushViewOfFile(
    lpBaseAddress: *const c_void,
    dwNumberOfBytesToFlush: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn UnmapViewOfFile(
    lpBaseAddress: *const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetLargePageMinimum(
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetProcessWorkingSetSizeEx(
    hProcess: HANDLE,
    lpMinimumWorkingSetSize: *usize,
    lpMaximumWorkingSetSize: *usize,
    Flags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetProcessWorkingSetSizeEx(
    hProcess: HANDLE,
    dwMinimumWorkingSetSize: usize,
    dwMaximumWorkingSetSize: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualLock(
    lpAddress: *c_void,
    dwSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn VirtualUnlock(
    lpAddress: *c_void,
    dwSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetWriteWatch(
    dwFlags: u32,
    lpBaseAddress: *c_void,
    dwRegionSize: usize,
    lpAddresses: ?[*]?*c_void,
    lpdwCount: ?*usize,
    lpdwGranularity: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ResetWriteWatch(
    lpBaseAddress: *c_void,
    dwRegionSize: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateMemoryResourceNotification(
    NotificationType: MEMORY_RESOURCE_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn QueryMemoryResourceNotification(
    ResourceNotificationHandle: HANDLE,
    ResourceState: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetSystemFileCacheSize(
    lpMinimumFileCacheSize: *usize,
    lpMaximumFileCacheSize: *usize,
    lpFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn SetSystemFileCacheSize(
    MinimumFileCacheSize: usize,
    MaximumFileCacheSize: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CreateFileMappingNumaW(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: PAGE_TYPE,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?[*:0]const u16,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn PrefetchVirtualMemory(
    hProcess: HANDLE,
    NumberOfEntries: usize,
    VirtualAddresses: [*]WIN32_MEMORY_RANGE_ENTRY,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn CreateFileMappingFromApp(
    hFile: HANDLE,
    SecurityAttributes: ?*SECURITY_ATTRIBUTES,
    PageProtection: PAGE_TYPE,
    MaximumSize: u64,
    Name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn MapViewOfFileFromApp(
    hFileMappingObject: HANDLE,
    DesiredAccess: FILE_MAP,
    FileOffset: u64,
    NumberOfBytesToMap: usize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn UnmapViewOfFileEx(
    BaseAddress: *c_void,
    UnmapFlags: UNMAP_VIEW_OF_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn AllocateUserPhysicalPages(
    hProcess: HANDLE,
    NumberOfPages: *usize,
    PageArray: [*]usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FreeUserPhysicalPages(
    hProcess: HANDLE,
    NumberOfPages: *usize,
    PageArray: [*]usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn MapUserPhysicalPages(
    VirtualAddress: *c_void,
    NumberOfPages: usize,
    PageArray: ?[*]usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn AllocateUserPhysicalPagesNuma(
    hProcess: HANDLE,
    NumberOfPages: *usize,
    PageArray: [*]usize,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn VirtualAllocExNuma(
    hProcess: HANDLE,
    lpAddress: ?*c_void,
    dwSize: usize,
    flAllocationType: VIRTUAL_ALLOCATION_TYPE,
    flProtect: u32,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn GetMemoryErrorHandlingCapabilities(
    Capabilities: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn RegisterBadMemoryNotification(
    Callback: PBAD_MEMORY_CALLBACK_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn UnregisterBadMemoryNotification(
    RegistrationHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.1'
pub extern "KERNEL32" fn OfferVirtualMemory(
    VirtualAddress: [*]u8,
    Size: usize,
    Priority: OFFER_PRIORITY,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "KERNEL32" fn ReclaimVirtualMemory(
    VirtualAddress: [*]const u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.1'
pub extern "KERNEL32" fn DiscardVirtualMemory(
    VirtualAddress: [*]u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-3" fn SetProcessValidCallTargets(
    hProcess: HANDLE,
    VirtualAddress: *c_void,
    RegionSize: usize,
    NumberOfOffsets: u32,
    OffsetInformation: [*]CFG_CALL_TARGET_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-memory-l1-1-7" fn SetProcessValidCallTargetsForMappedView(
    Process: HANDLE,
    VirtualAddress: *c_void,
    RegionSize: usize,
    NumberOfOffsets: u32,
    OffsetInformation: [*]CFG_CALL_TARGET_INFO,
    Section: HANDLE,
    ExpectedFileOffset: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-3" fn VirtualAllocFromApp(
    BaseAddress: ?*c_void,
    Size: usize,
    AllocationType: VIRTUAL_ALLOCATION_TYPE,
    Protection: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-3" fn VirtualProtectFromApp(
    Address: *c_void,
    Size: usize,
    NewProtection: u32,
    OldProtection: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-3" fn OpenFileMappingFromApp(
    DesiredAccess: u32,
    InheritHandle: BOOL,
    Name: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows10.0.14393'
pub extern "api-ms-win-core-memory-l1-1-4" fn QueryVirtualMemoryInformation(
    Process: HANDLE,
    VirtualAddress: *const c_void,
    MemoryInformationClass: WIN32_MEMORY_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 4?
    MemoryInformation: *c_void,
    MemoryInformationSize: usize,
    ReturnSize: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "api-ms-win-core-memory-l1-1-5" fn MapViewOfFileNuma2(
    FileMappingHandle: HANDLE,
    ProcessHandle: HANDLE,
    Offset: u64,
    BaseAddress: ?*c_void,
    ViewSize: usize,
    AllocationType: u32,
    PageProtection: u32,
    PreferredNode: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "api-ms-win-core-memory-l1-1-5" fn UnmapViewOfFile2(
    Process: HANDLE,
    BaseAddress: *c_void,
    UnmapFlags: UNMAP_VIEW_OF_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-memory-l1-1-5" fn VirtualUnlockEx(
    Process: HANDLE,
    Address: *c_void,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-6" fn VirtualAlloc2(
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Size: usize,
    AllocationType: VIRTUAL_ALLOCATION_TYPE,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows10.0.17134'
pub extern "api-ms-win-core-memory-l1-1-6" fn MapViewOfFile3(
    FileMapping: HANDLE,
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Offset: u64,
    ViewSize: usize,
    AllocationType: VIRTUAL_ALLOCATION_TYPE,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-6" fn VirtualAlloc2FromApp(
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Size: usize,
    AllocationType: VIRTUAL_ALLOCATION_TYPE,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-memory-l1-1-6" fn MapViewOfFile3FromApp(
    FileMapping: HANDLE,
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Offset: u64,
    ViewSize: usize,
    AllocationType: VIRTUAL_ALLOCATION_TYPE,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "api-ms-win-core-memory-l1-1-7" fn CreateFileMapping2(
    File: HANDLE,
    SecurityAttributes: ?*SECURITY_ATTRIBUTES,
    DesiredAccess: u32,
    PageProtection: PAGE_TYPE,
    AllocationAttributes: u32,
    MaximumSize: u64,
    Name: ?[*:0]const u16,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalAlloc(
    uFlags: GLOBAL_ALLOC_FLAGS,
    dwBytes: usize,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalReAlloc(
    hMem: isize,
    dwBytes: usize,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalSize(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalUnlock(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalLock(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalFlags(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalHandle(
    pMem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GlobalFree(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalAlloc(
    uFlags: LOCAL_ALLOC_FLAGS,
    uBytes: usize,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalReAlloc(
    hMem: isize,
    uBytes: usize,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalLock(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) *c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalHandle(
    pMem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalUnlock(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalSize(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) usize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalFlags(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn LocalFree(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) isize;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (11)
//--------------------------------------------------------------------------------
const PWSTR = @import("../system/system_services.zig").PWSTR;
const MEM_EXTENDED_PARAMETER = @import("../system/system_services.zig").MEM_EXTENDED_PARAMETER;
const HEAP_INFORMATION_CLASS = @import("../system/system_services.zig").HEAP_INFORMATION_CLASS;
const PROCESS_HEAP_ENTRY = @import("../system/system_services.zig").PROCESS_HEAP_ENTRY;
const FILE_MAP = @import("../system/system_services.zig").FILE_MAP;
const MEMORY_BASIC_INFORMATION = @import("../system/system_services.zig").MEMORY_BASIC_INFORMATION;
const HANDLE = @import("../system/system_services.zig").HANDLE;
const SECURITY_ATTRIBUTES = @import("../system/system_services.zig").SECURITY_ATTRIBUTES;
const CFG_CALL_TARGET_INFO = @import("../system/system_services.zig").CFG_CALL_TARGET_INFO;
const BOOL = @import("../system/system_services.zig").BOOL;
const PAGE_TYPE = @import("../system/system_services.zig").PAGE_TYPE;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PBAD_MEMORY_CALLBACK_ROUTINE")) { _ = PBAD_MEMORY_CALLBACK_ROUTINE; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("std").builtin.is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
